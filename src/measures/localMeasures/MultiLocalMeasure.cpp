#include "MultiLocalMeasure.hpp"
#include <vector>
#include <iostream>

using namespace std;

const string MultiLocalMeasure::autogenMatricesFolder = "matrices/autogenerated/";

MultiLocalMeasure::MultiLocalMeasure(vector<Graph>* GV, string name) : Measure(name), graphs(GV){
}

MultiLocalMeasure::MultiLocalMeasure():Measure("mlm"){}; //dummy declare

MultiLocalMeasure::~MultiLocalMeasure() {
}

double MultiLocalMeasure::eval(const MultiAlignment& A) {
    double similaritySum = 0;
    double temp = 0;
    vector<vector<ushort> > mapping = A.getUpAlign();
    for (uint i = 0; i < (*graphs).size() - 1; i++) {
        for (uint j = i + 1; j < (*graphs).size(); j++) {
            temp = 0;
            uint n = (*graphs)[i].getNumNodes();
            for (uint k = 0; k < n; k++) {
                temp += sims[i][j][k][A[i][k]];
            }
            temp /= n;
            similaritySum += temp;
        }
    }
    double numCombination = (*graphs).size() * ((*graphs).size() - 1) / 2;
    return similaritySum/numCombination;
}

bool MultiLocalMeasure::isLocal() {
    return true;
}

vector<vector<vector<vector<float> > > >* MultiLocalMeasure::getSimMatrix() {
    return &sims;
}

void MultiLocalMeasure::loadBinSimMatrix(string simMatrixFileName) {
    /*
    if (fileExists(simMatrixFileName)) {
        uint n1 = G1->getNumNodes();
        uint n2 = G2->getNumNodes();
        sims = vector<vector<float> > (n1, vector<float> (n2));
        //readMatrixFromBinaryFile(sims, simMatrixFileName); //Not sure about where this function is.
    } // No change to this part because no file exists before write, always go to else for now.
    else {
    */
        cerr << "Computing " << simMatrixFileName << " ... ";
        Timer T;
        T.start();
        initSimMatrix();
        cerr << "done (" << T.elapsedString() << ")" << endl;
        //writeMatrixToBinaryFile(sims, simMatrixFileName); //Not sure about where this function is.
    //}
}

void MultiLocalMeasure::writeSimsWithNames(string outfile) {
    for (uint i = 0; i < (*graphs).size() - 1; i++) {
        for (uint j = i + 1; j < (*graphs).size(); j++) {
	    map<ushort,string> mapG1 = (*graphs)[i].getIndexToNodeNameMap();
            map<ushort,string> mapG2 = (*graphs)[j].getIndexToNodeNameMap();
            uint n1 = (*graphs)[i].getNumNodes();
            uint n2 = (*graphs)[j].getNumNodes();
            ofstream fout(outfile);
            for (uint k = 0; k < n1; k++) {
                for (uint l = 0; l < n2; l++) {
                    fout << mapG1[k] << " " << mapG2[l] << " " << sims[i][j][k][l] << endl;
                }
            }
        }
    }
}

double MultiLocalMeasure::eval(const Alignment& A) {return 0;};//dummy declare
